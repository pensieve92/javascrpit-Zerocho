## 14-1. 테트리스 세팅과 switch문  
createDocumentFragment > fragment  

td들을 화면에 직접 추가하는 게 아니라, (화면에 직접추가하면 비용이 크기때문에 )
 fragment를 먼저 만들어서, append를 하고, fragment를 마지막에 한번에 붙여준다.
 fragment는 메모리, tetris는 화면
 메모리에서 조작하는것은 빠름, 화면에서 조작은 느림
 메모리에서 먼저 조작하고, 화면에다 붙임

 배열의 call by sharing과 관련이 있는것 같다...아닌가.??
 w3schools 예시 봤는데 이해가 안간다...... 
 나중에 다시 찾아서 정리 해야디..ㅜㅜ

```javascript
var tetris = document.querySelector('#tetris');
var tetrisData = [];

function 칸만들기 () {
    var fragment = document.createDocumentFragment();
    for (var i = 0; i < 20; i++ ){
        var tr = document.creatElement('tr');
        fragment.appendChild(tr);
        for(var j = 0; j< 10; j++ ){
            var td = document.createElement('td');
            tr.appendChild(td);
        }
    }
    tetris.appendChild(fragment);
}

```
swich문
```javascript
// break의 유무에 따라 동작이 달라집니다.
// break를 안걸면 아래 case가 같이 실행된다.
// 의도적으로 break를 안거는 경우도 있다.
window.addEventListener('keyup', function(e){
   console.log(e.key);
   switch(e.code){
    case 'Space':
        break;
    case 'ArrowRight':
        break;
    case 'ArrowLeft':
        break;
    case 'ArrowDown':
        default;
    case 'ArrowUp':
        break;
    default :
        break;
   }
})

```
## 14-2. keyup, keydown, keypress  
keyup  
손가락이 떼지는 순간  
  
keydown  
계속 누르고 있으면 문제가 생길수가 있어서 잘 사용안함  
  
keypress  
keydownr과 동일, 방향키는 인식 안됨  
  

```javascript
// 꾹 누를 수 있게 하기위해 keydown
window.addEventListener('keydown', function(e){
   console.log(e.key);
   switch(e.code){    
    case 'ArrowRight':
        break;
    case 'ArrowLeft':
        break;
    case 'ArrowDown':
        default;
        break;
    default :
        break;
   }
})

// 한번만 누르게 하기위해 keyup
window.addEventListener('keyup', function(e){
   console.log(e.key);
   switch(e.code){
    case 'Space':   // 한방에 내리기
        break;
    case 'ArrowUp':
        break;
    default :
        break;
   }
})
```

## 14-3. 테트리스 블록 데이터 만들기  

```javascript
var tetris = document.querySelector('#tetris');
var blockArr = [
    ['red', true, [
        [1, 1],
        [1, 1]
    ] ],
    ['blue', true, [
        [0, 1, 0],
        [1, 1, 1]
    ] ],
    ['orange', true, [
        [1, 1, 0],
        [0, 1, 1]
    ] ],
    ['skyblue', true, [  
        [0, 1, 1],
        [1, 1, 0]
    ] ],
    ['yellowgreen', true, [
        [1, 1, 1],
        [1, 0, 0]
    ] ],
    ['pink', true, [  
        [1, 1, 1],
        [0, 0, 1]
    ] ],
    ['yellow', true, [
        [1, 1, 1, 1]        
    ] ],
]
var blockDict = {
    // 색, 이동가능여부, 모양
    1: ['red', true, [
        [1, 1],
        [1, 1]
    ] ], 
    2: ['blue', true, [
        [0, 1, 0],
        [1, 1, 1]
    ] ],
    3: ['orange', true, [
        [1, 1, 0],
        [0, 1, 1]
    ] ],
    4: ['skyblue', true, [  
        [0, 1, 1],
        [1, 1, 0]
    ] ],
    5: ['yellowgreen', true, [
        [1, 1, 1],
        [1, 0, 0]
    ] ],
    6: ['pink', true, [  
        [1, 1, 1],
        [0, 0, 1]
    ] ],
    7: ['yellow', true, [
        [1, 1, 1, 1]        
    ] ],
    10: ['red', false, [] ], 
    20: ['blue', false, [] ],
    30: ['orange', false, [] ],
    40: ['skyblue', false, [] ],
    50: ['yellowgreen', false, [] ],
    60: ['pink', false, [] ],
    70: ['yellow', false, [] ],
}
var tetrisData = [];

function 칸만들기 () {
    var fragment = document.createDocumentFragment();
    for (var i = 0; i < 20; i++ ){
        var tr = document.creatElement('tr');
        var arr = [];
        tetrisData.push(arr);
        fragment.appendChild(tr);        
        for(var j = 0; j< 10; j++ ){
            var td = document.createElement('td');
            tr.appendChild(td);
            arr.push(0);
        }
    }
    console.log(tetrisData);
    tetris.appendChild(fragment);
}
```

## 14-4. 테트리스 블록화면에 표시  

## 14-5. 내려가는 테트리스 만들기  
// TODO:  블록 생성할 때 이미 차있으면 
## 14-6. 호출 스택과 이벤트 루프  
## 14-7. ES2015 const, let 화살표 함수  
## 14-8. 테트리스 블록 생성, 그리기  
## 14-9. 한 칸씩 내리기, 다 찬 줄 지우기  
## 14-10. 테트리스 좌우 이동, 내리기, 회전  
## 14-11. 테트리스 및 웹게임 강좌 마무리  
