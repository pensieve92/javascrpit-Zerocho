## 11-1. 카드 뒤집기 구현  
클로저 문제 발생: 반복문안의 비동기함수 호출시, 비동기 함수 내부의 변수에 영향을 준다.  
```javascript
function 카드세팅(가로, 세로){
    for(var i = 0; i< 가로 * 세로; i+=1){               // 반복문
        var card = document.createElement('div');
        card.className = 'card';
        ...
        (function(c){
            card.addEventListener('click', function(){ // 2. 클로저 문제가 여기는 상관이 없는데 
            // c.addEventListener('click',function(){  // 1. 이걸로 해야되는거 아님??            
                c.classList.toggle('flipped'); // 3. 이줄에서 비동기 함수의 호출로 클로저 문제가 발생하므로 card. >> c. 으로 수정함  
            })
        })(card)
    }
}
```
## 11-2. 카드 색 부여하기   
반복문 + 비동기 호출 >> 클로저 문제가 나야하는데 왜안났을까?
```javascript
document.querySelectorAll('.card').forEach(function(card, index){ // 반복문
    setTimeout(function(){
        card.classList.add('flipped');        // 비동기 함수
    }, 1000 + 100 * index)
})
여기에서 클로저문제가 발생해서, 즉시실행함수로 감싸주어야 한다고 생각했습니다.
근데 따로 즉시실행함수로 감싸주지 않아서 질문드립니다.
for문과 forEach와 클로저 문제가 다른점이 있는지?? 아니면 setTimeout() 이라서 문제가 안되는지? 궁금합니다.
```
## 11-3. 카드 짝 맞추기  

## 11-4. 게임 초기화  
참조관계 끊기  
```javascript
var 색깔들 = ['red', 'red', 'orange', 'orange', 'green','green', 'yellow', 'yellow'];
var 색깔후보 = 색깔들;
var 색깔 = [];

function 셔플(){
    for(var i = 0; 색깔후보.length > 0; i++) { // 색깔후보에서 하나씩 뺄때, 색깔들에서도 하나씩 빠짐... // 객체 참조 // 새로운게 복사가 아니라 색깔후보를 바꿔도 색깔들이 바뀜
        색깔 = 색깔.concat(색깔후보.splice(Math.floor(Math.random() * 색깔후보.length), 1));
    }
}
... 

색깔후보 = 색깔들;
색깔=[];
완성카드 =[]
셔플(); 
```

```javascript
var 색깔들 = ['red', 'red', 'orange', 'orange', 'green','green', 'yellow', 'yellow'];
var 색깔후보 = 색깔들.slice(); // slice()로 참조관계를 끊는다.
var 색깔 = [];

function 셔플(){
    for(var i = 0; 색깔후보.length > 0; i++) { // [색깔후보]에서 하나씩 뺄때, [색깔들]에서도 하나씩 빠짐... // 객체 참조 // 새로운게 복사가 아니라 색깔후보를 바꿔도 색깔들이 바뀜
        색깔 = 색깔.concat(색깔후보.splice(Math.floor(Math.random() * 색깔후보.length), 1));
    }
}
... 

색깔후보 = 색깔들.slice() // slice()로 참조관계를 끊는다.
색깔=[];
완성카드 =[]
셔플(); 

```
## 11-5. 참조와 복사  
slice효과
```javascript
var 색깔들 = ['red', 'red', 'orange', 'orange', 'green','green', 'yellow', 'yellow']; // 백업용
var 색깔후보 = 색깔들 //
```
복사
[원시값(문자, 숫자, 불린)]은 대입으로 [복사]할 수 있습니다. >> 값을 넣어줘도 따로따로 동작  

[객체 (객체, 배열, 함수)]는 대입하면 [참조관계]가 됩니다.

문자 복사
```javascript
var 값 = '코카콜라';
var 복사 = 값;          
복사                    //코카콜라
복사 = '펩시';          // 펩시
값                      // 코카콜라
```

불린 복사
```javascript
var 값 = true;
var 복사 = 값;          
복사                    // true
복사 = false            // false
값                      // true
```

객체 참조
```javascript
var 사람 = { 이름 : '흥부'} ;
var 복제인간 = 사람;
복제인간                // { 이름 : '흥부'};
복제인간.이름 = '놀부';
복제인간                // { 이름 : '놀부'};
사람                    // { 이름 : '놀부'};

```
함수 참조
```javascript
var 함수 = function(){};
함수.abc = 'abc';       // abc
복사 = 함수             // f() {}
복사.abc                // abc
복사.abc = 'def';       // def
함수.abc                // def

```

## 11-6. 복사하는 방법  
원시값은 참조 자체가 안된다.  
객체를 복사하는 법  

```javascript
var obj = {a: 1, b: 2};
var obj2 = {}

// 원시값 옮기기
obj2.a  = obj.a;
obj2.b  = obj.b;

// 객체를 대입하면 참조가 되기 때문에, 원시값을 대입해서 객체를  복사한다.

```

```javascript
var obj = {a: 1, b: 2};
var obj2 = {}

// Object.keys(obj) // ["a", "b"] : obj의 key값을 배열로 리턴
Object.keys(obj).forEach(function(key){
    Obj2[key] = obj[key];
})

```

객체간의 참조관계확인  
```javascript
var obj = {a: 1, b: 2};
var obj2 = obj;

obj === obj2;   // true

```

```javascript
var obj = {a: 1, b: 2};
var obj2 = {}   // 껍데기 부터 다름 ㅋㅋ

// Object.keys(obj) // ["a", "b"] : obj의 key값을 배열로 리턴
Object.keys(obj).forEach(function(key){
    Obj2[key] = obj[key];
})

obj === obj2;   // false 
```

객체 안의 객체  
```javascript
var obj = {a: 1, b: { c: 1 } };
var obj2 = {};
Object.keys(obj).forEach(function(key){
    Obj2[key] = obj[key];
})

obj === obj2;   // false 
```

얕은복사 => 참조  
깊은복사 => 복사  

## 11-7. 깊은 복사  
## 11-8. 팩토리 패턴과 프로토타입  
## 11-9. 프로토타입을 쓰는 이유  
## 11-10. Object.create()  